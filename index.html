<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <script src="matter.min.js"></script>
  <link rel="stylesheet" href="design.css">
  <canvas id="canvas"></canvas>
  <div id="UI">
    <button id="btn" onclick="modeChangeBtn()">スコアアタック</button>
    <h2 id="score">score:0</h2>
    <div id="view"><label for="skin">スキン変更</label>
      <input type="checkbox" id="skin">
    </div>
  </div><br>
  色変更(テスト用)<input type="color" id="color" value="#ffffff">

  <script>
    const { Engine, Render, Bodies, Composite, Runner, Body, World } = Matter;
    window.addEventListener("DOMContentLoaded", function () {
      matter_init();
      Matter.Events.on(engine, "afterUpdate", function () {

        sound();
        if (mode == "scoreMode") scoreMode();
        if (ball.position.x < R || ball.position.x > size - R) { Body.setVelocity(ball, { x: -ball.velocity.x / 2, y: ball.velocity.y }); }
        if (ball.position.y < R || ball.position.y > size - R) { Body.setVelocity(ball, { x: ball.velocity.x, y: -ball.velocity.y / 2 }); }
        Body.setPosition(ball, { x: clampNumber(ball.position.x, R, size - R), y: clampNumber(ball.position.y, R, size - R) });
        if (distance(ball.position, goal.position) < (R + goalR)) {
          score++; document.getElementById("score").innerText = "score:" + score;
          var posx;
          while (true) {
            posx = Math.random() * (size - R - goalR) + goalR;
            if (Math.abs(posx - ball.position.x) > goalR + R) break;
          }
          Body.setPosition(goal, { x: posx, y: (Math.random() * size / 2 + R) });
          Body.setVelocity(ball, { x: 0, y: 0 });
        }
      });
    });
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const btn = document.getElementById("btn");
    canvas.addEventListener("mousedown", () => {
      if (wait && mode == "scoreMode") {
        Render.run(render);
        Runner.run(runner, engine);
        wait = false;
      }
    });
    var color = document.getElementById("color");
    color.addEventListener("change", () => {
      if (!stream) return;
      for (var k = 0; k < index; k++)barView[k].render.fillStyle = color.value;
      //Body.render.fillStyle(bar[i], "red");
    })
    let radix = 1.5, index = 15, size = 640, blank = 10, R = 64, goalR = R / 2, barWid = 32, score = 0;
    let analyser, freq, min, max, stream;
    let bar = Array(index), barView = Array(index);
    const constraint = Array(index);
    let ball, goal, mode = "normal";
    let engine, runner, render;
    async function matter_init() {
      engine = Engine.create();
      render = Render.create({
        engine: engine,
        canvas: canvas,
        options: {
          width: size,
          height: size, id: "can",
          wireframes: false,
          background: "black"
        }
      });
      ball = Bodies.circle(size / 2, size / 2, R, {
        friction: 0, frictionAir: 0, restitution: 0.5, render: {
          fillStyle: '#ffffff',
          sprite: { texture: "ball.png", xScale: R * 2.0 / 545, yScale: R * 2.0 / 546 }
        }
      });
      goal = Bodies.circle(500, 300, goalR, {
        friction: 0, frictionAir: 0, restitution: 0.5, isStatic: true, render: {
          fillStyle: '#ffffff', options: {
            wireframes: false
          },
          sprite: { texture: "sports_archery_mato1.png", xScale: goalR * 2.0 / 373, yScale: goalR * 2.0 / 373 },
          collisionFilter: -1
        }
      });
      Composite.add(engine.world, [ball, goal]);
      Render.run(render);
      // create runner
      runner = Runner.create();
      // run the engine
      Runner.run(runner, engine);

      // マイク許可
      stream = await navigator.mediaDevices.getUserMedia({ audio: true, autoGainControl: true });
      for (var i = 0; i < index; i++) {
        bar[i] = Bodies.rectangle(i * (size - blank) / index + barWid / 2 + blank, size * 1.5, barWid, size, {
          isStatic: true,
          chamfer: { radius: barWid / 2 },
          render: { visible: false }
        });
        barView[i] = Bodies.rectangle(bar[i].position.x, bar[i].position.y, barWid, size, {
          isStatic: true,
          render: {
            fillStyle: color.value,
          }, collisionFilter: -1,

        });
      }
      Composite.add(engine.world, bar);
      Composite.add(engine.world, barView);
      // AudioContext 作成
      const audioCtx = new AudioContext();
      // マイク → AudioNode
      const source = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 32768;

      source.connect(analyser);

      freq = new Uint8Array(analyser.frequencyBinCount);//110より小さく880より大きく
      min = Math.floor(110 / (audioCtx.sampleRate / analyser.fftSize));
      max = Math.ceil(880 / (audioCtx.sampleRate / analyser.fftSize)) + 1;
    }
    let barBlank = 20;
    let blankHeight = blank / 2;
    function sound() {
      if (!stream) return;

      analyser.getByteFrequencyData(freq);
      var left = 0;
      ctx.fillStyle = "black";
      for (var i = 1; i <= index; i++) {
        var right = Math.ceil((radix ** i) * (max - min + 1) / (radix ** index)) - 1;//1からなので範囲が1小さくなる
        var num = freq.slice(left + min, right + min);
        var sum = (num.reduce((currentTotal, num) => currentTotal + num, 0));
        average = sum / num.length;
        //Body.translate(bar[i - 1], { x: 0, y: soundLog[i - 1] - average }, [updateVelocity = false])
        Body.setPosition(bar[i - 1], { x: bar[i - 1].position.x, y: size * 1.5 - average }, [updateVelocity = true]);
        Body.setPosition(barView[i - 1], { x: bar[i - 1].position.x, y: bar[i - 1].position.y });
        if (document.getElementById("skin").checked) {
          for (var j = 1; j < average / barBlank; j++)
            ctx.fillRect(bar[i - 1].position.x - barWid / 2, size - j * barBlank, barWid, blankHeight);
        }
        left = right;
      }
    }
    let time, remain, text, wait;
    function scoreMode() {
      if (new Date().getTime() - time > (30 - remain) * 1000) {
        remain -= 0.1
        text = remain.toFixed(1);
      }
      if (remain <= 0) {
        text = "終了"; wait = true; mode = "result"; btn.hidden = false; btn.textContent = "終了";
        document.getElementById("score").innerText = "←ボタンを押して終了";
        Runner.stop(runner);
        Render.stop(render);
      }
      ctx.fillStyle = "white";
      ctx.textAlign = "right";
      ctx.textBaseline = "top";
      ctx.fillText(text, size, 0);
      if (wait) {
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("score:" + score, size / 2, size / 2);
        ctx.lineWidth = "1px";
        ctx.strokeText("score:" + score, size / 2, size / 2);
      }
    }
    function clampNumber(num, a, b) {
      return Math.max(Math.min(num, Math.max(a, b)), Math.min(a, b));
    }
    function distance(pos1, pos2) {
      return Math.sqrt((pos1.x - pos2.x) ** 2 + (pos1.y - pos2.y) ** 2);
    }
    function modeChangeBtn() {
      if (mode == "normal") {
        Runner.stop(runner);
        Render.stop(render);
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "32px serif";
        ctx.lineWidth = "1px";
        ctx.fillText("画面をタップしてスタート", size / 2, size / 2);
        ctx.strokeText("画面をタップしてスタート", size / 2, size / 2);
        mode = "scoreMode";
        time = new Date().getTime();
        text = remain = 30.0;
        Body.setPosition(ball, { x: size / 2, y: size / 2 });
        Body.setPosition(goal, { x: 500, y: 300 });
        Body.setVelocity(ball, { x: 0, y: 0 });
        wait = true;
        document.getElementById("btn").hidden = true;
      }
      else if (mode == "result") {
        mode = "normal";
        btn.textContent = "スコアアタック";
        Render.run(render);
        Runner.run(runner, engine);
      }
      score = 0;
      document.getElementById("score").innerText = "score:0";
    }
  </script>
</head>

</html>
